# Best Practices

This document outlines recommendations and best practices for using Currency.js effectively in your applications.

## Avoid Floating Point Arithmetic

When working with monetary values, never use standard JavaScript floating point arithmetic. This can lead to precision errors that compound over time.

```javascript
// ❌ Bad: using floating point
const subtotal = 19.99
const tax = subtotal * 0.07   // 1.3993000000000002
const total = subtotal + tax  // 21.389300000000002

// ✅ Good: using Money
const subtotal = Money(19.99)
const tax = subtotal.percentage(7)
const total = subtotal.plus(tax) // 21.39
```

## Chain Operations for Readability

Take advantage of the method chaining capability for clearer and more concise code:

```javascript
// ✅ Good: chaining for readability
const finalPrice = Money(100)
  .applyDiscount(10)  // Apply 10% discount
  .applySurcharge(5)  // Add 5% fee
  .times(2)           // Double the amount
  .round(20)          // Round to 2 decimal places
```

## Leverage Immutability

All operations in Currency.js return new Money instances, preserving the original value. This immutability helps prevent unexpected side effects:

```javascript
const original = Money(100)
const discounted = original.applyDiscount(10)

console.log(original.value)   // Still 100
console.log(discounted.value) // 90
```

## Use Allocate for Distribution

When distributing money (such as for payment installments), always use the `allocate` method instead of `dividedBy`. This ensures that the sum of the parts is exactly equal to the original amount:

```javascript
// ❌ Less precise: using dividedBy for installments
const totalAmount = Money(100)
const installments = 3
const eachInstallment = totalAmount.dividedBy(installments) // 33.33
const totalSum = eachInstallment.times(installments)        // 99.99 (loss of 0.01)

// ✅ More precise: using allocate for installments
const totalAmount = Money(100)
const installments = totalAmount.allocate(3) // [33.34, 33.33, 33.33]
// The sum is exactly equal to the original value
```

## Format Money Values Consistently

Ensure consistent display of monetary values throughout your application by setting default format options:

```javascript
// Configure default formatting options once
const AppMoney = Money.configure({
  currencyCode: 'USD',
  locale: 'en-US',
  showSymbol: true,
  minimumFractionDigits: 2,
  maximumFractionDigits: 2,
})

// Use the configured function consistently throughout your app
const price1 = AppMoney(10.5)
const price2 = AppMoney(99.99)
```

## Handle Zero Values Carefully

When working with percentages or applying calculations to zero values, be explicit:

```javascript
// Check for zero values before operations when necessary
const price = Money(0)
const discount = price.isZero() ? Money(0) : price.percentage(10)
```

## Type-Safe Comparisons

For proper comparisons, always convert values to Money objects:

```javascript
// ❌ Less safe: comparing with raw values
if (price.value > 100) { /* ... */ }

// ✅ More safe: using comparison methods
if (price.greaterThan(Money(100))) { /* ... */ }
```

## Use Calculator API for Collections

When working with collections of monetary values, leverage the Calculator API:

```javascript
import { Calculator } from '@eriveltonsilva/currency.js'

// Process collections efficiently
const items = [
  { name: 'Product 1', price: 10.5, quantity: 2 },
  { name: 'Product 2', price: 15.75, quantity: 1 },
]

// Calculate total cart value
const totalCartValue = Calculator.calculateTotal(items)
```

## Consider Performance for Large Operations

For applications performing a large number of money operations, consider creating a pool of Money instances or using the Calculator API for batch operations to improve performance.